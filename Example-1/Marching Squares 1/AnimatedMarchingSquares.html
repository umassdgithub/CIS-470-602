<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Isoline</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="simplexNoise.js"></script>
    <style>
        .container{
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            font-family: sans-serif;
        }
        .cells{
            width: 50%;
        }
    </style>
</head>
<body>
<div class="container">
    <h1 class="cells">Isolines generated by Marching Squares</h1>
</div>
<div class="container">
    <p class="cells">The red and blue dots are used to represent the binary values of two differnt regions generated by <a href="https://en.wikipedia.org/wiki/Perlin_noise">Perling noise</a>.Perlin noise is a type of gradient noise developed by Ken Perlin in 1983. </p>
</div>

<div class="container">
    <div style="width: 800px;height: 600px" id="figure">
    </div>
<script>

    const openSimplex = openSimplexNoise(100);
    const figure = document.getElementById("figure");
    const w = figure.clientWidth;
    const h = figure.clientHeight;
    const radius = 4;
    const padding = 5;
    const xDim = 40; // number of the nodes in x axis direction
    const yDim = 40; // number of the nodes in y axis direction
    const anim_len = 500;
    const offsetX = 1;
    const offsetY = 1;

    function draw(frame) {
        let old_svg=d3.select('svg');
        if(old_svg!==undefined){
            old_svg.remove();
        }
        function rand_bit() {
            if (Math.random(1) > .5) {
                return 1;
            } else {
                return 0;
            }
        }
        function rand_frame(frame,offsetX,offsetY)
        {
            return Math.ceil(openSimplex.noise3D(offsetX, offsetY,frame))
        }
        function detect_Type_2(Matrix, i, j) {
            let edges = [
                [(Matrix[i][j] + Matrix[i + 1][j]) / 2,
                    (i + i + 1) / 2,
                    (j + j) / 2],
                [(Matrix[i + 1][j] + Matrix[i + 1][j + 1]) / 2,
                    (i + 1 + i + 1) / 2,
                    (j + j + 1) / 2],
                [(Matrix[i + 1][j + 1] + Matrix[i][j + 1]) / 2,
                    (i + i + 1) / 2,
                    (j + 1 + j + 1) / 2],
                [(Matrix[i][j + 1] + Matrix[i][j]) / 2,
                    (i + i) / 2,
                    (j + j + 1) / 2]
            ]
            let connections = []
            for (let k = 0; k < 4; k++) {
                if (edges[k][0] === .5) {
                    connections.push({x: edges[k][1], y: edges[k][2]})
                }
            }
            return connections;
        }

        let svg = d3.select(figure).append("svg")
            .attr('width', '100%')
            .attr('height', '100%');

        let plot = svg.append('g')
            .attr('id', 'plot')
        let canvas = []
        let xScale = d3.scaleLinear()
            .domain([0, xDim])
            .range([padding, w - padding])
        let yScale = d3.scaleLinear()
            .domain([yDim, 0])
            .range([padding, h - padding])


        let color = d => {
            if (d === 0) {
                return 'red'
            } else {
                return 'steelblue'
            }
        }

        for (let i = 0; i < xDim; i++) {
            let tmp = [xDim]
            canvas.push(tmp)
        }
        // create random bits
        let offsetX = 0.0;
        let offsetY = 0.0;
        for (let i = 0; i < xDim; i++) {
            offsetX+=1;
            for (let j = 0; j < yDim; j++) {
                canvas[i][j] = rand_frame(frame, offsetX,offsetY);
                offsetY +=1;
                plot.append('circle')
                    .attr('cx', xScale(i))
                    .attr('cy', yScale(j))
                    .attr('r', radius)
                    .style('fill', color(canvas[i][j]))
            }
        }

        const lineGen = d3.line()
        finalLine = ""
        for (let i = 0; i < xDim-1; i++)
            for (let j = 0; j < yDim-1; j++) {
                let tmp = detect_Type_2(canvas, i, j);
                if (tmp.length === 2) {
                    plot.append('line')
                        .attr('stroke', 'black')
                        .attr('stroke-width', 1.5)
                        .attr("stroke-opacity",.5)
                        .attr('x1', xScale(tmp[0]['x']))
                        .attr('y1', yScale(tmp[0]['y']))
                        .attr('x2', xScale(tmp[1]['x']))
                        .attr('y2', yScale(tmp[1]['y']));

                }
                if (tmp.length === 4) {

                    plot.append('line')
                        .style('stroke', 'black')
                        .attr('x1', xScale(tmp[0]['x']))
                        .attr('y1', yScale(tmp[0]['y']))
                        .attr('x2', xScale(tmp[1]['x']))
                        .attr('y2', yScale(tmp[1]['y']));

                    plot.append('line')
                        .style('stroke', 'black')
                        .attr('x1', xScale(tmp[2]['x']))
                        .attr('y1', yScale(tmp[2]['y']))
                        .attr('x2', xScale(tmp[3]['x']))
                        .attr('y2', yScale(tmp[3]['y']));
                }
            }
    }

    function callme(duraion){

        if (duraion>=anim_len*100)
        {
            timer.stop()
        }
        //if(parseInt(duraion)%2===0){
            draw(frame_count);
            frame_count++;
        //}
    }
    let frame_count = 0


    const intervalId = setInterval(callme, 100);


</script>
</body>
</html>